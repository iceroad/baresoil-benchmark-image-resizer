doctype html
html(lang='en')
  head
    title= 'Baresoil Image Processing Benchmark: ' + extVariables.runName
    meta(charset='utf-8')
    meta(name='description', content= extVariables.runDesc)
    meta(name='viewport', content='width=device-width, initial-scale=1')
    link(rel='stylesheet', href='assets/bootstrap.min.css')
    link(rel='stylesheet', href='assets/style.css')

  body
    div(class='container-fluid')
      //-
      //- TITLE
      //-
      div(class='row')
        div(class='col-xs-12 bottom-spacer')
          h1(class='text-center') Baresoil Image Processing Benchmark (AWS)

      //-
      //- INTRODUCTION
      //-
      div(class='row')
        div(class='col-xs-12 col-md-5 col-md-offset-1 col-lg-4 col-lg-offset-2 bottom-spacer')
          h4 Introduction
          p
            em Benchmark time:&nbsp;
            strong= extVariables.runStartTime
          p.
            This benchmark load tests a user-uploaded image processing API hosted
            on a Baresoil cluster. The image processing performed is basic
            cropping, image adjustments, and metadata extraction from a JPEG
            image, using the Unix command-line tool ImageMagick.

          p.
            A Baresoil cluster of the dimensions below is first created on Amazon
            AWS using the standard Baresoil cluster setup tool. This includes
            assigning the load balancer to a top-level DNS domain name secured
            by a TLS certificate.

          p.
            Then, a separate client tier of #[strong= extVariables.client.instances.count]
            instances is created in the same AWS region as the server, to generate
            traffic for the server. Each server in the client tier spawns
            #[strong= expConfig.numAgents] indepenent processes that each perform
            the following steps in a loop:
          ol
            li.
              Make an HTTP POST request to the server's DNS name with one of
              four sample JPEG images, each between 9 and 11 Megabytes.
            li.
              Wait for the server to return the resized versions of the image.
            li.
              Wait a small amount of time, loop back to step 1.

          p.
            All requests from the client tier are sent over multipart HTTPS requests
            via Curl to the top-level domain name of the server cluster. As a result,
            the benchmarks here are for SSl/TLS-secured traffic.

        //-
        //- TOP-LINE METRICS
        //-
        div(class='col-xs-12 col-md-5 col-lg-4')
          h4 Bottom-line Metrics
          table(class='table table-compact metrics-table')
            tr
              td Images processed per hour
              td(class='metric format-number')= analysis.Aggregates.bottomLine.imagesPerHour

            tr
              td Image data processed per hour
              td(class='metric')
                span(class='format-number')= analysis.Aggregates.bottomLine.imageDataPerHourGB
                strong  GB

            tr
              td Cluster cost per hour (on-demand)#[sup *]
              td(class='metric')
                span= '$' + analysis.Aggregates.bottomLine.costPerHourRetail
                strong  USD

            tr
              td Cluster cost per hour (reserved)
              td(class='metric')
                span= '$' + analysis.Aggregates.bottomLine.costPerHourReserved
                strong  USD
          p.
            #[sup *] Assumes #[strong= extVariables.server.instances.count]
            on-demand EC2
            #[strong= extVariables.server.instances.type]
            instances priced at
            $#[strong= extVariables.server.instances.costPerHour.retail] per hour,
            RDS on-demand costs of $#[strong= extVariables.server.rds.costPerHour]
            per hour, ELB costs of $#[strong= extVariables.server.elb.costPerHour]
            per hour and $#[strong= extVariables.server.elb.costPerGB] per gigabyte
            transferred.

      //-
      //- EXPERIMENT CONFIG
      //-
      div(class='row')
        div(class='col-xs-12 text-center')
          h3 Experiment
          hr
        div(class='col-xs-6 col-md-2 col-md-offset-2 bottom-spacer')
          h4 Client Tier
          table(class='table table-compact metrics-table')
            tr
              td Instance Count
              td(class='metric')= extVariables.client.instances.count
            tr
              td Instance Type
              td(class='metric')= extVariables.client.instances.type
            tr
              td AWS Region
              td(class='metric')= extVariables.client.region
        div(class='col-xs-6 col-md-2 bottom-spacer')
          h4 Server Tier
          table(class='table table-compact metrics-table')
            tr
              td Instance Count
              td(class='metric')= extVariables.server.instances.count
            tr
              td Instance Type
              td(class='metric')= extVariables.server.instances.type
            tr
              td AWS Region
              td(class='metric')= extVariables.server.region
            tr
              td Cost per hour (on-demand)
              td(class='metric')
                span= '$' + extVariables.server.instances.costPerHour.retail
                strong  USD
            tr
              td Cost per hour (reserved)
              td(class='metric')
                span= '$' + extVariables.server.instances.costPerHour.reserved
                strong  USD
        div(class='col-xs-6 col-md-4 bottom-spacer')
          h4 Raw Stats
          table(class='table table-compact metrics-table')
            tr
              td Experiment time (seconds)
              td(class='metric format-number')= analysis.Aggregates.totalTimeSec
            tr
              td Requests made
              td(class='metric format-number')= analysis.Aggregates.numRequestsMade
            tr
              td Successful responses received
              td(class='metric format-number')= analysis.Aggregates.numRequestsOk
            tr
              td Error responses received
              td(class='metric format-number')= analysis.Aggregates.numRequestsFail
            tr
              td Image bytes processed by the cluster
              td(class='metric format-number')= analysis.Aggregates.imgBytesSent
            tr
              td Total response bytes returned from cluster
              td(class='metric format-number')= analysis.Aggregates.rawBytesRecv
            tr
              td Total CPU-seconds used by all requests
              td(class='metric format-number')= analysis.Aggregates.totalCpuSeconds


      //-
      //- REQUEST STATS
      //-
      div(class='row')
        div(class='col-xs-12 text-center')
          h3 Request Statistics
          hr
      div(class='row')
        div(class='col-xs-12 col-md-5 col-md-offset-1 bottom-spacer')
          h4 Request Rate
          p.
            Total number of requests that were initiated to the server
            in each time window, aggregated over all clients.
          canvas(id='new_requests_over_time')
        div(class='col-xs-12 col-md-5 bottom-spacer')
          h4 Image Bytes Processed
          p.
            Total amount of image data processed by the cluster at each time
            window. Image data is only counted when it is successfully
            processed by the cluster and returned, at the time of return.
          canvas(id='image_bytes_over_time')
      div(class='row')
        div(class='col-xs-12 col-md-5 col-md-offset-1 bottom-spacer')
          h4 Server Time per Image
          p.
            Wall time spent by server on resizing each image, as reported by
            the server.
          canvas(id='walltime_per_image_over_time')
        div(class='col-xs-12 col-md-5 bottom-spacer')
          h4 Round-trip Latency
          p.
            Time from starting the HTTP POST request to receiving a successful
            response. Requests are grouped by the time they were started at the
            client, not when the response was successfully received.
          canvas(id='rtt_latency_over_time')

      //-
      //- CLIENT HEALTH
      //-
      div(class='row')
        div(class='col-xs-12 text-center')
          h3 Client Tier Statistics
          hr
      div(class='row')
        div(class='col-xs-12 col-md-5 col-md-offset-1 bottom-spacer')
          h4 Client CPU Usage
          p.
            Instances in the client tier should not be overloaded in order to ensure that server response measurements are not biased. The following time series plot shows average CPU usage for each server in the client tier.
          canvas(id='client_cpu_over_time')

        div(class='col-xs-12 col-md-5 bottom-spacer')
          h4 Client Memory Usage
          p.
            The following time series plot shows the percentage of system memory used per host, as free by node's builtin #[code os] module.
          canvas(id='client_memory_over_time')

      div(class='row')
        div(class='col-xs-12 col-md-5 col-md-offset-1 bottom-spacer')
          h4 Concurrent Agents
          p.
            Each agent is an independent process running on one of the client tier instances that makes a continuous stream of requests to the server. The following time series plot shows the total number of active agents over time for all client tier hosts.
          canvas(id='num_agents_over_time')

    //-
    //- End of script loaders
    //-
    script(src='data.js')
    script(src='assets/jquery-3.2.1.slim.min.js')
    script(src='assets/Chart.bundle.min.js')
    script(src='assets/app.js')
